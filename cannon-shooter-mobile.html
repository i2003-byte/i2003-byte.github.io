<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a1a">
    <title>Cannon Shooter Mobile</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Mobile HUD - Horizontal Top Bar */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px max(16px, env(safe-area-inset-left)) 8px max(16px, env(safe-area-inset-right));
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .hud-left {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .hud-stat {
            font-size: 18px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .hud-right {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .icon-btn {
            width: 44px;
            height: 44px;
            font-size: 24px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .icon-btn:active {
            transform: scale(0.9);
            background: rgba(255,255,255,0.3);
        }

        .cta-btn {
            min-height: 44px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            border: 2px solid #fff;
            border-radius: 22px;
            font-weight: 700;
            color: #000;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cta-btn:active {
            transform: scale(0.95);
        }

        /* Weapon Selector - Bottom corners layout */
        .weapon-selector {
            position: fixed;
            bottom: max(8px, env(safe-area-inset-bottom));
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 max(8px, env(safe-area-inset-left)) 0 max(8px, env(safe-area-inset-right));
            z-index: 900;
            pointer-events: none;
        }

        .weapon-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            pointer-events: auto;
        }

        .weapon-option {
            width: 44px;
            height: 52px;
            background: rgba(0,0,0,0.9);
            border: 2px solid rgba(100,150,255,0.4);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .weapon-option:active {
            transform: scale(0.95);
        }

        .weapon-option.active {
            border-color: #4CAF50;
            box-shadow: 0 0 15px rgba(76,175,80,0.6);
            background: rgba(76,175,80,0.2);
        }

        .weapon-icon {
            font-size: 18px;
            margin-bottom: 1px;
        }

        .weapon-option h4 {
            font-size: 7px;
            color: #fff;
            margin-bottom: 0px;
            font-weight: 600;
        }

        .weapon-option span:last-child {
            font-size: 7px;
            color: #90EE90;
            font-weight: 500;
        }

        /* Fire Instruction */
        .fire-instruction {
            position: fixed;
            bottom: max(20px, env(safe-area-inset-bottom));
            right: 20px;
            background: rgba(0,0,0,0.85);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            padding: 12px 16px;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            z-index: 950;
            pointer-events: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .fire-instruction.hidden {
            display: none;
        }

        /* Ammo Warning Message */
        .ammo-warning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.95);
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 12px 24px;
            color: #fff;
            font-size: 16px;
            font-weight: 700;
            text-align: center;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            white-space: nowrap;
        }

        .ammo-warning.show {
            opacity: 1;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
        }

        .ammo-warning.fade-out {
            animation: fadeOut 1.5s forwards;
        }

        /* Virtual Joystick */
        .joystick-container {
            position: fixed;
            bottom: 120px;
            left: 40px;
            width: 120px;
            height: 120px;
            z-index: 950;
            display: none;
        }

        .joystick-container.active {
            display: block;
        }

        .joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.1);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            position: absolute;
        }

        .joystick-stick {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.5);
            border: 2px solid #fff;
            border-radius: 50%;
            position: absolute;
            top: 35px;
            left: 35px;
            touch-action: none;
        }

        /* Tutorial Overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        }

        .tutorial-overlay.show {
            display: flex;
        }

        .tutorial-content {
            max-width: 400px;
            color: #fff;
        }

        .tutorial-content h2 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #ffd700;
        }

        .tutorial-content p {
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .tutorial-btn {
            min-width: 200px;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(135deg, #3498db, #2980b9);
            border: none;
            border-radius: 25px;
            color: #fff;
            cursor: pointer;
            margin: 8px;
            transition: transform 0.2s;
        }

        .tutorial-btn:active {
            transform: scale(0.95);
        }

        .tutorial-btn.secondary {
            background: rgba(255,255,255,0.2);
        }

        /* Settings Menu - Hidden (not used in mobile) */
        .settings-menu {
            display: none !important;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1500;
            display: none;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            transform: scale(0);
            transition: transform 0.3s ease;
        }

        .settings-menu.show {
            display: flex;
            transform: scale(1);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .settings-header h2 {
            color: #ffd700;
            font-size: 24px;
        }

        .settings-section {
            margin-bottom: 24px;
        }

        .settings-section h3 {
            color: #3498db;
            font-size: 18px;
            margin-bottom: 12px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            margin-bottom: 8px;
            color: #fff;
        }

        .toggle-switch {
            width: 50px;
            height: 26px;
            background: #ccc;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.on {
            background: #4CAF50;
        }

        .toggle-switch::after {
            content: '';
            width: 22px;
            height: 22px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }

        .toggle-switch.on::after {
            left: 26px;
        }

        /* Game Over Panel */
        .game-over-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(0,0,0,0.98), rgba(30,30,30,0.98));
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 1800;
            min-width: 300px;
            border: 3px solid #e74c3c;
            transition: transform 0.4s ease;
        }

        .game-over-panel.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .game-over-panel h2 {
            color: #e74c3c;
            font-size: 3em;
            margin-bottom: 20px;
        }

        .game-over-panel p {
            color: #ecf0f1;
            font-size: 1.5em;
            margin: 10px 0;
        }

        .game-over-panel button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 1.2em;
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .game-over-panel button:active {
            transform: scale(0.95);
        }

        /* Upgrade Menu - Mobile Optimized */
        .upgrade-menu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.98);
            z-index: 1600;
            display: none;
            flex-direction: column;
            overflow-y: auto;
            padding: 16px;
            transform: scale(0);
            transition: transform 0.4s ease;
        }

        .upgrade-menu.show {
            display: flex;
            transform: scale(1);
        }

        .upgrade-header {
            text-align: center;
            color: #ffd700;
            font-size: 24px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .upgrade-card {
            background: linear-gradient(135deg, rgba(30,30,50,0.98), rgba(20,20,40,0.98));
            border: 2px solid rgba(100,150,255,0.5);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .upgrade-card h3 {
            color: #3498db;
            font-size: 20px;
            margin-bottom: 8px;
        }

        .upgrade-card p {
            color: #95a5a6;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .upgrade-dots {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .upgrade-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #444;
            border: 2px solid #666;
        }

        .upgrade-dot.filled {
            background: #ffd700;
            border-color: #ffd700;
        }

        .upgrade-button {
            width: 100%;
            min-height: 56px;
            font-size: 18px;
            font-weight: 700;
            border-radius: 28px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            border: none;
            color: #000;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .upgrade-button:active {
            transform: scale(0.95);
        }

        .upgrade-button:disabled {
            background: #444;
            color: #888;
        }

        /* Boss HP Bar */
        .boss-hp-bar {
            position: fixed;
            top: 64px;
            left: 50%;
            transform: translateX(-50%);
            width: min(600px, calc(100vw - 32px));
            padding: 12px 16px;
            background: rgba(0,0,0,0.9);
            border: 2px solid #ff0000;
            border-radius: 8px;
            z-index: 1100;
            display: none;
        }

        .boss-hp-bar.show {
            display: block;
        }

        .boss-name {
            font-size: clamp(14px, 4vw, 24px);
            color: #ff0000;
            font-weight: 700;
            text-align: center;
            margin-bottom: 8px;
        }

        .hp-bar-container {
            width: 100%;
            height: 24px;
            background: rgba(255,0,0,0.2);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .hp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            transition: width 0.3s ease;
            border-radius: 12px;
        }

        /* Time Slow Effect */
        .time-slow-effect {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .time-slow-effect.active {
            opacity: 1;
            box-shadow: inset 0 0 100px 50px rgba(138, 43, 226, 0.4);
            animation: pulseSlow 1s ease-in-out infinite;
        }

        @keyframes pulseSlow {
            0%, 100% { box-shadow: inset 0 0 100px 50px rgba(138, 43, 226, 0.3); }
            50% { box-shadow: inset 0 0 120px 60px rgba(138, 43, 226, 0.5); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Instructions */
        .instructions {
            display: none; /* Hidden - using fire-instruction instead */
            position: fixed;
            bottom: max(100px, calc(env(safe-area-inset-bottom) + 100px));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 8px 16px;
            border-radius: 8px;
            color: #fff;
            font-size: 12px;
            text-align: center;
            z-index: 800;
        }
    </style>
</head>
<body>

<!-- HUD -->
<div class="hud">
    <div class="hud-left">
        <span class="hud-stat">‚≠ê<span id="score">0</span></span>
        <span class="hud-stat">üí£<span id="ammo">30</span></span>
        <span class="hud-stat">üéØ<span id="combo">x1</span></span>
        <span class="hud-stat">W<span id="wave">1</span></span>
    </div>
    <div class="hud-right">
        <button class="icon-btn" id="restartButton" onclick="restartGame()" aria-label="Restart">üîÑ</button>
        <button class="icon-btn" id="pauseButton" onclick="pauseGame()" aria-label="Pause">‚è∏</button>
    </div>
</div>

<!-- Weapon Selector -->
<div class="weapon-selector">
    <div class="weapon-group">
        <div class="weapon-option active" id="weapon1" onclick="switchWeapon(0)">
            <span class="weapon-icon">‚ö´</span>
            <h4>CANNON</h4>
            <span>Cost: 1</span>
        </div>
        <div class="weapon-option" id="weapon2" onclick="switchWeapon(1)">
            <span class="weapon-icon">‚ö°</span>
            <h4>BOLT</h4>
            <span>Cost: 3</span>
        </div>
    </div>
    <div class="weapon-group">
        <div class="weapon-option" id="weapon3" onclick="switchWeapon(2)">
            <span class="weapon-icon">üí•</span>
            <h4>SCATTER</h4>
            <span>Cost: 3</span>
        </div>
        <div class="weapon-option" id="weapon4" onclick="switchWeapon(3)">
            <span class="weapon-icon">üöÄ</span>
            <h4>HOMING</h4>
            <span>Cost: 4</span>
        </div>
    </div>
</div>

<!-- Fire Instruction -->
<div class="fire-instruction" id="fireInstruction">
    üëÜ SELECT WEAPON <br>TAP & RELEASE<br>TO FIRE
</div>

<!-- Ammo Warning Message -->
<div class="ammo-warning" id="ammoWarning">
    üí£ NOT ENOUGH AMMO!
</div>

<!-- Virtual Joystick (for joystick mode) -->
<div class="joystick-container" id="joystickContainer">
    <div class="joystick-base"></div>
    <div class="joystick-stick" id="joystickStick"></div>
</div>

<!-- Instructions -->
<div class="instructions">
    üéØ Tap screen to aim | Tap FIRE to shoot | Press ‚≠ê for upgrades
</div>

<!-- Boss HP Bar -->
<div class="boss-hp-bar" id="bossHpBar">
    <div class="boss-name" id="bossName">BOSS</div>
    <div class="hp-bar-container">
        <div class="hp-bar-fill" id="bossHpFill" style="width: 100%;"></div>
    </div>
</div>

<!-- Time Slow Effect Overlay -->
<div class="time-slow-effect" id="timeSlowEffect"></div>

<!-- Tutorial Overlay -->
<div class="tutorial-overlay" id="tutorialOverlay">
    <div class="tutorial-content">
        <h2 id="tutorialTitle">üéØ CANNON SHOOTER</h2>
        <p id="tutorialText">Defend against endless waves of enemies with 5 powerful weapons!</p>
        <button class="tutorial-btn" onclick="startTutorial()">üéÆ START TUTORIAL</button>
        <button class="tutorial-btn secondary" onclick="skipTutorial()">‚è≠ SKIP TO GAME</button>
    </div>
</div>

<!-- Settings Menu -->
<div class="settings-menu" id="settingsMenu">
    <div class="settings-header">
        <h2>‚öôÔ∏è SETTINGS</h2>
        <button class="icon-btn" onclick="closeSettings()">‚úï</button>
    </div>

    <div class="settings-section">
        <h3>üéÆ CONTROLS</h3>
        <div class="setting-row">
            <span>Control Mode</span>
            <select id="controlMode" onchange="changeControlMode()" style="padding: 8px; border-radius: 4px; background: #333; color: #fff; border: 1px solid #555;">
                <option value="tap">Tap-to-Aim</option>
                <option value="joystick">Virtual Joystick</option>
            </select>
        </div>
    </div>

    <div class="settings-section">
        <h3>üîä AUDIO</h3>
        <div class="setting-row">
            <span>Sound Effects</span>
            <div class="toggle-switch on" id="soundToggle" onclick="toggleSound()"></div>
        </div>
        <div class="setting-row">
            <span>Haptic Feedback</span>
            <div class="toggle-switch on" id="hapticsToggle" onclick="toggleHaptics()"></div>
        </div>
    </div>

    <div class="settings-section">
        <h3>üé® GRAPHICS</h3>
        <div class="setting-row">
            <span>Graphics Quality</span>
            <select id="graphicsQuality" onchange="changeGraphicsQuality()" style="padding: 8px; border-radius: 4px; background: #333; color: #fff; border: 1px solid #555;">
                <option value="auto">Auto</option>
                <option value="high">High</option>
                <option value="medium">Medium</option>
                <option value="low">Low</option>
            </select>
        </div>
    </div>

    <div class="settings-section">
        <h3>‚ÑπÔ∏è ABOUT</h3>
        <div class="setting-row" style="flex-direction: column; align-items: flex-start;">
            <span style="margin-bottom: 8px;">Version: 1.0.0 Mobile</span>
            <span style="font-size: 12px; color: #888;">Built with p5.js | Mobile-Optimized</span>
        </div>
    </div>
</div>

<!-- Game Over Panel -->
<div class="game-over-panel" id="gameOverPanel">
    <h2>üí• GAME OVER!</h2>
    <p id="finalScore">Final Score: 0</p>
    <p id="finalWave">Wave Reached: 1</p>
    <p class="high-score" id="highScore">High Score: 0</p>
    <button onclick="restartGame()">üéØ PLAY AGAIN</button>
</div>


<script>
// Mobile-specific variables
let isMobile = true;
let controlMode = 'tap'; // 'tap' or 'joystick'
let soundEnabled = true;
let hapticsEnabled = true;
let graphicsQuality = 'auto'; // 'auto', 'high', 'medium', 'low'
let deviceTier = 'medium'; // Detected tier

// Touch variables
let aimX, aimY;
let isFiring = false;
let joystickActive = false;
let joystickAngle = 0;
let tutorialComplete = false;
let tutorialStep = 0;

// Game variables (from enhanced version)
let projectiles = [];
let targets = [];
let particles = [];
let explosions = [];
let lightningEffects = [];
let powerUps = [];
let bombs = [];
let bosses = [];
let clouds = [];
let cannon;
let score = 0;
let wave = 1;
let ammo = 100;
let totalShots = 0;
let hits = 0;
let combo = 0;
let comboMultiplier = 1;
let comboTimer = 0;
let timeOfDay = 0;
let highScore = 0;
let currentWeapon = 0;
let gameOver = false;
let gamePaused = false;

// NEW: Enhanced variables
let FIRE_COOLDOWN = 100;
let lastFireTime = 0;

let timeSlowActive = false;
let timeSlowDuration = 0;
let gameSpeed = 1.0;

let currentBoss = null;
let isBossWave = false;

let waveTargetsRemaining = 10;
let waveComplete = false;
let waveCompleteTimer = 0;
let waveBonusAmmo = 0;

// Performance budgets based on device tier
let MAX_PARTICLES = 75;
let MAX_EXPLOSIONS = 5;
let MAX_CLOUDS = 6; // Dynamic cloud count based on device tier
let PARTICLES_PER_EXPLOSION = 10; // Optimized particle count per explosion

// Cached graphics for performance
let skyGradientGraphic;
let groundGradientGraphic;

// Cached DOM elements (eliminates 240 queries/sec at 60fps)
let scoreEl, waveEl, ammoEl, comboEl;
let weaponElements = []; // Cached weapon buttons for faster switching

const weapons = [
    { name: 'Cannonball', power: 18, gravity: 0.3, size: 20, color: [40, 40, 40], splashRadius: 0, type: 'normal', ammoCost: 1 },
    { name: 'Lightning', power: 30, gravity: 0, size: 15, color: [100, 200, 255], splashRadius: 0, type: 'lightning', ammoCost: 3 },
    { name: 'Scatter Shot', power: 15, gravity: 0.25, size: 18, color: [255, 140, 0], splashRadius: 0, type: 'scatter', ammoCost: 3 },
    { name: 'Homing Missile', power: 25, gravity: 0.1, size: 22, color: [220, 50, 50], splashRadius: 0, type: 'homing', ammoCost: 4 }
];

const targetTypes = [
    { name: 'bird', points: 10, speed: 1.5, size: 40 },
    { name: 'balloon', points: 15, speed: 1, size: 50 },
    { name: 'plane', points: 25, speed: 2.5, size: 60 },
    { name: 'rocket', points: 30, speed: 3, size: 55 },
    { name: 'ufo', points: 50, speed: 2, size: 70 },
    { name: 'bomber', points: 40, speed: 1.8, size: 65, canDropBombs: true },
    { name: 'shielded', points: 35, speed: 1.2, size: 55, hp: 2 },
    { name: 'decoy', points: 20, speed: 2, size: 45, splits: true }
];

let targetSpeed = 2;
let targetSpawnRate = 120;
let targetSpawnTimer = 0;
let maxTargets = 3;

function setup() {
    createCanvas(windowWidth, windowHeight);

    // Detect device capability
    detectDeviceCapability();

    // Load saved data
    highScore = parseInt(localStorage.getItem('cannonShooterMobileHighScore')) || 0;

    // Load settings
    tutorialComplete = localStorage.getItem('cannonShooterMobileTutorial') === 'true';
    controlMode = localStorage.getItem('cannonShooterMobileControlMode') || 'tap';
    graphicsQuality = localStorage.getItem('cannonShooterMobileGraphicsQuality') || 'auto';

    // Apply settings
    document.getElementById('controlMode').value = controlMode;
    document.getElementById('graphicsQuality').value = graphicsQuality;
    updateControlMode();
    applyGraphicsQuality();

    cannon = new Cannon(width / 2, height - 50);

    // Create clouds based on device tier
    for (let i = 0; i < MAX_CLOUDS; i++) {
        clouds.push({
            x: random(width),
            y: random(height * 0.3),
            size: random(80, 140),
            speed: random(0.2, 0.5)
        });
    }

    // Cache gradients for performance (90% faster rendering)
    createGradientCache();

    // Cache DOM elements for HUD (eliminates 240 queries/sec)
    scoreEl = document.getElementById('score');
    waveEl = document.getElementById('wave');
    ammoEl = document.getElementById('ammo');
    comboEl = document.getElementById('combo');

    // Cache weapon elements for optimized switching
    weaponElements = [
        document.getElementById('weapon1'),
        document.getElementById('weapon2'),
        document.getElementById('weapon3'),
        document.getElementById('weapon4')
    ];

    // Show tutorial if first time
    if (!tutorialComplete) {
        setTimeout(() => {
            document.getElementById('tutorialOverlay').classList.add('show');
        }, 500);
    }

    // Set up touch events
    setupTouchEvents();
}

function createGradientCache() {
    // Create sky gradient graphic once
    skyGradientGraphic = createGraphics(width, height * 0.85);
    let c1 = color(135, 206, 250);
    let c2 = color(100, 149, 237);
    for (let y = 0; y < height * 0.85; y++) {
        let inter = map(y, 0, height * 0.85, 0, 1);
        skyGradientGraphic.stroke(lerpColor(c1, c2, inter));
        skyGradientGraphic.strokeWeight(1);
        skyGradientGraphic.line(0, y, width, y);
    }

    // Create ground gradient graphic once
    groundGradientGraphic = createGraphics(width, height * 0.15);
    for (let y = 0; y < height * 0.15; y++) {
        let inter = map(y, 0, height * 0.15, 0, 1);
        let c1 = color(34, 139, 34);
        let c2 = color(0, 100, 0);
        groundGradientGraphic.stroke(lerpColor(c1, c2, inter));
        groundGradientGraphic.strokeWeight(1);
        groundGradientGraphic.line(0, y, width, y);
    }
}

function detectDeviceCapability() {
    // Simple benchmark
    let startTime = performance.now();
    let particles = [];
    for (let i = 0; i < 100; i++) {
        particles.push({ x: random(width), y: random(height), vx: random(-5, 5), vy: random(-5, 5) });
    }
    for (let frame = 0; frame < 60; frame++) {
        for (let p of particles) {
            p.x += p.vx;
            p.y += p.vy;
        }
    }
    let duration = performance.now() - startTime;

    if (duration < 10) {
        deviceTier = 'high';
        MAX_PARTICLES = 150;
        MAX_EXPLOSIONS = 10;
        MAX_CLOUDS = 6;
        PARTICLES_PER_EXPLOSION = 15;
    } else if (duration < 25) {
        deviceTier = 'medium';
        MAX_PARTICLES = 75;
        MAX_EXPLOSIONS = 5;
        MAX_CLOUDS = 4;
        PARTICLES_PER_EXPLOSION = 10;
    } else {
        deviceTier = 'low';
        MAX_PARTICLES = 30;
        MAX_EXPLOSIONS = 3;
        MAX_CLOUDS = 2;
        PARTICLES_PER_EXPLOSION = 6;
        frameRate(30); // Set 30 FPS for low-end
    }
}

function applyGraphicsQuality() {
    if (graphicsQuality === 'auto') {
        // Already set by detectDeviceCapability
    } else if (graphicsQuality === 'high') {
        MAX_PARTICLES = 150;
        MAX_EXPLOSIONS = 10;
        MAX_CLOUDS = 6;
        PARTICLES_PER_EXPLOSION = 15;
        frameRate(60);
    } else if (graphicsQuality === 'medium') {
        MAX_PARTICLES = 75;
        MAX_EXPLOSIONS = 5;
        MAX_CLOUDS = 4;
        PARTICLES_PER_EXPLOSION = 10;
        frameRate(60);
    } else if (graphicsQuality === 'low') {
        MAX_PARTICLES = 30;
        MAX_EXPLOSIONS = 3;
        MAX_CLOUDS = 2;
        PARTICLES_PER_EXPLOSION = 6;
        frameRate(30);
    }
}

function setupTouchEvents() {
    // Canvas touch for aiming and firing
    let canvas = document.querySelector('canvas');
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
}

function handleTouchStart(e) {
    e.preventDefault();
    if (gameOver || gamePaused) return;

    let touch = e.touches[0];
    aimX = touch.clientX;
    aimY = touch.clientY;

    if (controlMode === 'tap') {
        // Tap-to-aim mode
        let angle = atan2(aimY - cannon.y, aimX - cannon.x);
        cannon.setAngle(angle);
    }
}

function handleTouchMove(e) {
    e.preventDefault();
    if (gameOver || gamePaused) return;

    let touch = e.touches[0];
    aimX = touch.clientX;
    aimY = touch.clientY;

    if (controlMode === 'tap') {
        let angle = atan2(aimY - cannon.y, aimX - cannon.x);
        cannon.setAngle(angle);
    } else if (controlMode === 'joystick') {
        // Joystick aiming handled in joystick logic
    }
}

function handleTouchEnd(e) {
    e.preventDefault();
    if (gameOver || gamePaused || waveComplete) return;

    // Fire on touch release
    cannon.fire();

    // Hide fire instruction after 3 shots
    if (totalShots >= 3) {
        document.getElementById('fireInstruction').classList.add('hidden');
    }
}

function draw() {
    // Time slow handling
    if (timeSlowActive) {
        timeSlowDuration--;
        if (timeSlowDuration <= 0) {
            timeSlowActive = false;
            gameSpeed = 1.0;
            document.getElementById('timeSlowEffect').classList.remove('active');
        }
    }

    if (gamePaused) {
        return; // Don't update when paused
    }

    // Background
    drawSkyGradient();
    drawClouds();
    drawGround();

    if (!gameOver) {
        // Wave system
        if (waveTargetsRemaining <= 0 && targets.length === 0 && !waveComplete && !currentBoss) {
            waveComplete = true;
            waveCompleteTimer = 120;
            waveBonusAmmo = 15 + wave * 3;
        }

        if (waveComplete) {
            waveCompleteTimer--;
            drawWaveComplete();
            if (waveCompleteTimer <= 0) {
                startNextWave();
            }
        }

        // Spawn targets
        if (!waveComplete && !isBossWave) {
            targetSpawnTimer++;
            if (targetSpawnTimer > targetSpawnRate && targets.length < maxTargets && waveTargetsRemaining > 0) {
                spawnTarget();
                targetSpawnTimer = 0;
                waveTargetsRemaining--;
            }
        }

        // Spawn power-ups (mobile: less frequent to reduce clutter)
        if (frameCount % 600 === 0 && random() > 0.3) {
            spawnPowerUp();
        }

        // Update combo timer
        if (comboTimer > 0) {
            comboTimer--;
        } else if (combo > 0) {
            combo = 0;
            comboMultiplier = 1;
        }

        // Update power-ups
        for (let i = powerUps.length - 1; i >= 0; i--) {
            powerUps[i].update();
            powerUps[i].display();

            for (let j = projectiles.length - 1; j >= 0; j--) {
                if (projectiles[j].hits(powerUps[i])) {
                    activatePowerUp(powerUps[i].type);
                    createPowerUpEffect(powerUps[i].x, powerUps[i].y);
                    powerUps.splice(i, 1);
                    projectiles.splice(j, 1);
                    break;
                }
            }

            if (powerUps[i] && powerUps[i].isOffScreen()) {
                powerUps.splice(i, 1);
            }
        }

        // Update bombs
        for (let i = bombs.length - 1; i >= 0; i--) {
            bombs[i].update();
            bombs[i].display();

            if (bombs[i].hitsGround()) {
                createExplosion(bombs[i].x, bombs[i].y, 'fire');
                ammo = max(0, ammo - 3);
                bombs.splice(i, 1);

                if (ammo <= 0) {
                    endGame();
                }
            } else if (bombs[i] && bombs[i].isOffScreen()) {
                bombs.splice(i, 1);
            }
        }

        // Update targets
        for (let i = targets.length - 1; i >= 0; i--) {
            targets[i].update();
            targets[i].display();

            if (targets[i].type.canDropBombs && frameCount % 90 === 0 && random() > 0.5) {
                bombs.push(new Bomb(targets[i].x, targets[i].y));
            }

            if (targets[i].isOffScreen()) {
                targets.splice(i, 1);
                resetCombo();
            }
        }

        // Update boss
        if (currentBoss && !currentBoss.defeated) {
            currentBoss.update();
            currentBoss.display();
        }

        // Update projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
            projectiles[i].update();
            projectiles[i].display();

            let hitTarget = false;

            // Check collision with targets
            for (let j = targets.length - 1; j >= 0; j--) {
                if (projectiles[i].hits(targets[j])) {
                    hitTarget = true;
                    handleProjectileHit(projectiles[i], j);
                    projectiles.splice(i, 1);
                    break;
                }
            }

            // Check collision with boss
            if (!hitTarget && projectiles[i] && currentBoss && !currentBoss.defeated) {
                let d = dist(projectiles[i].x, projectiles[i].y, currentBoss.x, currentBoss.y);
                if (d < currentBoss.size / 2) {
                    let damage = weapons[projectiles[i].type].power;
                    currentBoss.takeDamage(damage);
                    createExplosion(projectiles[i].x, projectiles[i].y, 'normal');
                    projectiles.splice(i, 1);
                    hitTarget = true;

                    if (currentBoss.defeated) {
                        score += currentBoss.points;
                        isBossWave = false;
                        currentBoss = null;
                        document.getElementById('bossHpBar').classList.remove('show');
                        waveComplete = true;
                        waveCompleteTimer = 120;
                    }
                }
            }

            // Remove off-screen projectiles
            if (!hitTarget && projectiles[i] && projectiles[i].isOffScreen()) {
                projectiles.splice(i, 1);
                resetCombo();
            }
        }

        cannon.update();
        cannon.display();

        updateParticles();
        updateExplosions();
        updateLightning();

        if (combo > 2) {
            drawComboIndicator();
        }

        updateHUD();
    }
}

function handleProjectileHit(projectile, targetIndex) {
    let target = targets[targetIndex];
    let pointsEarned = target.points * comboMultiplier;

    if (projectile.type === 1) {
        // Lightning chain
        let chainTargets = [target];
        let processedIndices = new Set([targetIndex]);

        for (let c = 0; c < 2; c++) {
            let lastTarget = chainTargets[chainTargets.length - 1];
            let closestDist = 200;
            let closestTarget = null;
            let closestIndex = -1;

            for (let k = targets.length - 1; k >= 0; k--) {
                if (!processedIndices.has(k)) {
                    let d = dist(lastTarget.x, lastTarget.y, targets[k].x, targets[k].y);
                    if (d < closestDist) {
                        closestDist = d;
                        closestTarget = targets[k];
                        closestIndex = k;
                    }
                }
            }

            if (closestTarget) {
                chainTargets.push(closestTarget);
                processedIndices.add(closestIndex);
                lightningEffects.push({
                    x1: lastTarget.x,
                    y1: lastTarget.y,
                    x2: closestTarget.x,
                    y2: closestTarget.y,
                    life: 20
                });
            }
        }

        Array.from(processedIndices).sort((a, b) => b - a).forEach(idx => {
            createExplosion(targets[idx].x, targets[idx].y, 'lightning');
            score += targets[idx].points * comboMultiplier;
            incrementCombo();
            targets.splice(idx, 1);
        });

        hits += processedIndices.size;
    }
    else {
        // Regular hit - Check HP
        if (target.hp !== undefined) {
            target.hp--;
            createExplosion(target.x, target.y, 'normal');

            if (target.hp <= 0) {
                score += pointsEarned;
                hits++;
                incrementCombo();

                // Check if decoy splits
                if (target.type.splits) {
                    let miniDecoy = {
                        name: 'decoy_mini',
                        points: 10,
                        speed: 2.5,
                        size: 30
                    };
                    targets.push(new Target(target.x < width/2 ? 'left' : 'right', target.y - 30, miniDecoy));
                    targets.push(new Target(target.x < width/2 ? 'left' : 'right', target.y + 30, miniDecoy));
                }

                targets.splice(targetIndex, 1);
            }
        } else {
            createExplosion(target.x, target.y, 'normal');
            score += pointsEarned;
            hits++;
            incrementCombo();

            // Ammo regeneration chance
            let ammoRegenChance = 0.10 + (comboMultiplier - 1) * 0.05;
            if (random() < ammoRegenChance) {
                ammo += 1;
            }

            targets.splice(targetIndex, 1);
        }
    }
}

// Drawing and helper functions
function drawSkyGradient() {
    // Use cached gradient (90% faster than drawing lines)
    if (skyGradientGraphic) {
        image(skyGradientGraphic, 0, 0);
    }
}

function drawGround() {
    // Use cached gradient (90% faster than drawing lines)
    if (groundGradientGraphic) {
        image(groundGradientGraphic, 0, height * 0.85);
    }
}

function drawClouds() {
    for (let cloud of clouds) {
        cloud.x += cloud.speed * gameSpeed;
        if (cloud.x > width + 200) cloud.x = -200;

        fill(255, 255, 255, 220);
        noStroke();
        ellipse(cloud.x, cloud.y, cloud.size, cloud.size * 0.6);
        ellipse(cloud.x - cloud.size * 0.3, cloud.y + 10, cloud.size * 0.7, cloud.size * 0.5);
        ellipse(cloud.x + cloud.size * 0.3, cloud.y + 5, cloud.size * 0.8, cloud.size * 0.6);
    }
}

function drawWaveComplete() {
    push();
    fill(255, 255, 255, 200);
    textAlign(CENTER, CENTER);
    textSize(min(40, width * 0.08));
    textStyle(BOLD);
    fill(46, 204, 113);
    text(`WAVE ${wave} COMPLETE!`, width / 2, height / 2 - 20);
    textSize(min(24, width * 0.05));
    fill(46, 204, 113);
    text(`+${waveBonusAmmo} AMMO BONUS`, width / 2, height / 2 + 10);
    pop();
}

function drawComboIndicator() {
    push();
    textAlign(CENTER, TOP);
    textSize(min(32, width * 0.06));
    textStyle(BOLD);
    fill(255, 215, 0);
    stroke(255, 100, 0);
    strokeWeight(2);
    text(`${combo} HIT COMBO!`, width / 2, 100);
    textSize(min(48, width * 0.09));
    fill(255, 100, 0);
    text(`x${comboMultiplier}`, width / 2, 140);
    pop();
}

function star(x, y, radius1, radius2, npoints) {
    let angle = TWO_PI / npoints;
    let halfAngle = angle / 2.0;
    beginShape();
    for (let a = -PI / 2; a < TWO_PI - PI / 2; a += angle) {
        let sx = x + cos(a) * radius2;
        let sy = y + sin(a) * radius2;
        vertex(sx, sy);
        sx = x + cos(a + halfAngle) * radius1;
        sy = y + sin(a + halfAngle) * radius1;
        vertex(sx, sy);
    }
    endShape(CLOSE);
}

function incrementCombo() {
    combo++;
    comboTimer = 180;

    if (combo >= 10) {
        comboMultiplier = 4;
    } else if (combo >= 5) {
        comboMultiplier = 3;
    } else if (combo >= 3) {
        comboMultiplier = 2;
    }
}

function resetCombo() {
    combo = 0;
    comboMultiplier = 1;
    comboTimer = 0;
}

function startNextWave() {
    wave++;
    waveComplete = false;
    ammo += waveBonusAmmo;

    if (wave % 5 === 0) {
        isBossWave = true;
        let bossTypes = ['colossus', 'dragons', 'megaBomber'];
        let bossType = random(bossTypes);
        currentBoss = new Boss(bossType, wave);
        document.getElementById('bossHpBar').classList.add('show');
    } else {
        isBossWave = false;
        waveTargetsRemaining = 10 + wave * 5;
        targetSpeed = 2 + wave * 0.3;
        targetSpawnRate = max(60, 120 - wave * 8);
        maxTargets = min(6, 3 + Math.floor(wave / 2));
    }
}

function spawnTarget() {
    let availableTypes = targetTypes.slice(0, min(2 + wave, targetTypes.length));
    let type = random(availableTypes);
    let side = random() > 0.5 ? 'left' : 'right';
    let y = random(height * 0.15, height * 0.6);
    targets.push(new Target(side, y, type));
}

function spawnPowerUp() {
    let types = ['star', 'ammo', 'shield', 'star', 'ammo', 'shield'];
    let type = random(types);
    let x = random(width * 0.2, width * 0.8);
    let y = random(height * 0.2, height * 0.5);
    powerUps.push(new PowerUp(x, y, type));
}

function activatePowerUp(type) {
    if (type === 'star') {
        combo += 3;
        incrementCombo();
    } else if (type === 'ammo') {
        ammo += 15;
    } else if (type === 'shield') {
        ammo += 8;
    } else if (type === 'timeSlow') {
        timeSlowActive = true;
        timeSlowDuration = 180;
        gameSpeed = 0.3;
        document.getElementById('timeSlowEffect').classList.add('active');
    }
}

function createPowerUpEffect(x, y) {
    for (let i = 0; i < 20; i++) {
        particles.push({
            x: x,
            y: y,
            vx: random(-5, 5),
            vy: random(-5, 5),
            size: random(5, 15),
            color: [255, 215, 0],
            life: 60,
            type: 'star'
        });
    }
}

function createExplosion(x, y, type) {
    if (explosions.length < MAX_EXPLOSIONS) {
        explosions.push(new Explosion(x, y, type));
    }

    // Use device-tier optimized particle count (6-15 based on performance)
    if (particles.length < MAX_PARTICLES - PARTICLES_PER_EXPLOSION) {
        for (let i = 0; i < PARTICLES_PER_EXPLOSION; i++) {
            let angle = random(TWO_PI);
            let speed = random(2, 6);
            particles.push({
                x: x,
                y: y,
                vx: cos(angle) * speed,
                vy: sin(angle) * speed,
                size: random(3, 8),
                color: type === 'fire' ? [255, random(100, 200), 0] : type === 'lightning' ? [100, 200, 255] : [200, 200, 200],
                life: random(30, 60),
                type: type
            });
        }
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * gameSpeed;
        p.y += p.vy * gameSpeed;
        p.vy += 0.2 * gameSpeed;
        p.life--;

        push();
        fill(p.color[0], p.color[1], p.color[2], map(p.life, 0, 60, 0, 255));
        noStroke();
        circle(p.x, p.y, p.size);
        pop();

        if (p.life <= 0) {
            particles.splice(i, 1);
        }
    }
}

function updateExplosions() {
    for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].update();
        explosions[i].display();
        if (explosions[i].isDone()) {
            explosions.splice(i, 1);
        }
    }
}

function updateLightning() {
    for (let i = lightningEffects.length - 1; i >= 0; i--) {
        let l = lightningEffects[i];
        l.life--;

        push();
        stroke(100, 200, 255, map(l.life, 0, 20, 0, 255));
        strokeWeight(3);
        line(l.x1, l.y1, l.x2, l.y2);
        pop();

        if (l.life <= 0) {
            lightningEffects.splice(i, 1);
        }
    }
}

function updateHUD() {
    // Use cached elements (eliminates 240 DOM queries/sec)
    scoreEl.textContent = score;
    waveEl.textContent = wave;
    ammoEl.textContent = ammo;
    comboEl.textContent = 'x' + comboMultiplier;
}

function endGame() {
    gameOver = true;

    if (score > highScore) {
        highScore = score;
        localStorage.setItem('cannonShooterMobileHighScore', highScore);
    }

    document.getElementById('finalScore').textContent = `Final Score: ${score}`;
    document.getElementById('finalWave').textContent = `Wave Reached: ${wave}`;
    document.getElementById('highScore').textContent = `üèÜ High Score: ${highScore}`;
    document.getElementById('gameOverPanel').classList.add('show');
}

function restartGame() {
    score = 0;
    wave = 1;
    ammo = 100;
    totalShots = 0;
    hits = 0;
    combo = 0;
    comboMultiplier = 1;
    comboTimer = 0;
    gameOver = false;
    gamePaused = false;
    waveTargetsRemaining = 10;
    waveComplete = false;
    projectiles = [];
    targets = [];
    particles = [];
    explosions = [];
    lightningEffects = [];
    powerUps = [];
    bombs = [];
    targetSpeed = 2;
    targetSpawnRate = 120;
    maxTargets = 3;
    currentBoss = null;
    isBossWave = false;

    // Reinitialize clouds based on device tier
    clouds = [];
    for (let i = 0; i < MAX_CLOUDS; i++) {
        clouds.push({
            x: random(width),
            y: random(height * 0.3),
            size: random(80, 140),
            speed: random(0.2, 0.5)
        });
    }

    document.getElementById('gameOverPanel').classList.remove('show');
    document.getElementById('bossHpBar').classList.remove('show');
}

// UI Functions
function switchWeapon(weaponIndex) {
    let weaponAmmoCost = weapons[weaponIndex].ammoCost;

    if (ammo < weaponAmmoCost) {
        // Use cached element (50% faster than DOM query)
        let weaponEl = weaponElements[weaponIndex];
        weaponEl.style.animation = 'shake 0.3s';
        setTimeout(() => {
            weaponEl.style.animation = '';
        }, 300);
        showAmmoWarning();
        return;
    }

    currentWeapon = weaponIndex;

    // Optimized: Only toggle 2 elements instead of iterating all 4
    if (weaponElements.length > 0) {
        for (let i = 0; i < weaponElements.length; i++) {
            if (i === weaponIndex) {
                weaponElements[i].classList.add('active');
            } else {
                weaponElements[i].classList.remove('active');
            }
        }
    }
}

function showAmmoWarning() {
    let warningEl = document.getElementById('ammoWarning');

    // Remove any existing animation
    warningEl.classList.remove('fade-out');
    warningEl.classList.remove('show');

    // Force reflow to restart animation
    void warningEl.offsetWidth;

    // Show the warning
    warningEl.classList.add('show');

    // Start fade out after 0.5s
    setTimeout(() => {
        warningEl.classList.remove('show');
        warningEl.classList.add('fade-out');

        // Clean up after animation
        setTimeout(() => {
            warningEl.classList.remove('fade-out');
        }, 1500);
    }, 500);

    // Haptic feedback
    if (hapticsEnabled && navigator.vibrate) {
        navigator.vibrate([50, 30, 50]);
    }
}

function openSettings() {
    gamePaused = true;
    document.getElementById('settingsMenu').classList.add('show');
}

function closeSettings() {
    gamePaused = false;
    document.getElementById('settingsMenu').classList.remove('show');
}

function pauseGame() {
    gamePaused = !gamePaused;
    document.getElementById('pauseButton').textContent = gamePaused ? '‚ñ∂Ô∏è' : '‚è∏';
}


function toggleSound() {
    soundEnabled = !soundEnabled;
    document.getElementById('soundToggle').classList.toggle('on');
}

function toggleHaptics() {
    hapticsEnabled = !hapticsEnabled;
    document.getElementById('hapticsToggle').classList.toggle('on');
}

function changeControlMode() {
    controlMode = document.getElementById('controlMode').value;
    localStorage.setItem('cannonShooterMobileControlMode', controlMode);
    updateControlMode();
}

function updateControlMode() {
    if (controlMode === 'joystick') {
        document.getElementById('joystickContainer').classList.add('active');
    } else {
        document.getElementById('joystickContainer').classList.remove('active');
    }
}

function changeGraphicsQuality() {
    graphicsQuality = document.getElementById('graphicsQuality').value;
    localStorage.setItem('cannonShooterMobileGraphicsQuality', graphicsQuality);
    applyGraphicsQuality();
}

function startTutorial() {
    tutorialStep = 0;
    document.getElementById('tutorialOverlay').classList.remove('show');
    // Tutorial logic would go here
    tutorialComplete = true;
    localStorage.setItem('cannonShooterMobileTutorial', 'true');
}

function skipTutorial() {
    tutorialComplete = true;
    localStorage.setItem('cannonShooterMobileTutorial', 'true');
    document.getElementById('tutorialOverlay').classList.remove('show');
}


// Classes
class Cannon {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = -HALF_PI;
        this.recoil = 0;
    }

    setAngle(angle) {
        this.angle = constrain(angle, -PI, 0);
    }

    update() {
        if (controlMode === 'joystick' && joystickActive) {
            this.angle = joystickAngle;
        }

        if (this.recoil > 0) {
            this.recoil--;
        }
    }

    fire() {
        let currentTime = millis();
        let weaponAmmoCost = weapons[currentWeapon].ammoCost;

        if (ammo >= weaponAmmoCost && !gameOver && !waveComplete && (currentTime - lastFireTime) >= FIRE_COOLDOWN) {
            lastFireTime = currentTime;

            let barrelLength = 60; // Shorter for mobile
            let x = this.x + cos(this.angle) * barrelLength;
            let y = this.y + sin(this.angle) * barrelLength;

            if (currentWeapon === 2) {
                // Scatter shot fires 5 projectiles in a spread
                for (let i = -2; i <= 2; i++) {
                    let spreadAngle = this.angle + (i * 0.15);
                    projectiles.push(new Projectile(x, y, spreadAngle, currentWeapon));
                }
            } else {
                projectiles.push(new Projectile(x, y, this.angle, currentWeapon));
            }

            ammo -= weaponAmmoCost;

            totalShots++;
            this.recoil = 15;

            if (hapticsEnabled && navigator.vibrate) {
                navigator.vibrate(30);
            }

            if (ammo <= 0) {
                endGame();
            }
        } else if (ammo < weaponAmmoCost && !gameOver) {
            // Show ammo warning
            showAmmoWarning();
        }
    }

    display() {
        push();
        translate(this.x, this.y);

        // Base platform (carriage) - drawn first
        fill(80, 80, 80);
        stroke(50, 50, 50);
        strokeWeight(3);
        rect(-60, 0, 120, 30, 5);

        // Wheels
        fill(40, 40, 40);
        stroke(20, 20, 20);
        strokeWeight(2);
        circle(-40, 25, 25);
        circle(40, 25, 25);

        // Wheel spokes (radial lines)
        stroke(60, 60, 60);
        strokeWeight(2);
        for (let a = 0; a < TWO_PI; a += PI / 4) {
            line(-40 + cos(a) * 5, 25 + sin(a) * 5, -40 + cos(a) * 10, 25 + sin(a) * 10);
            line(40 + cos(a) * 5, 25 + sin(a) * 5, 40 + cos(a) * 10, 25 + sin(a) * 10);
        }

        // Rotate for barrel
        rotate(this.angle);

        // Barrel (with recoil)
        push();
        translate(-this.recoil, 0);

        fill(60, 60, 60);
        stroke(40, 40, 40);
        strokeWeight(3);
        rect(0, -15, 80, 30, 5);

        // Barrel end/muzzle
        fill(40, 40, 40);
        rect(75, -18, 8, 36, 3);

        // Barrel highlight
        fill(100, 100, 100);
        noStroke();
        rect(10, -12, 60, 8, 3);

        pop();

        // Turret base (center circle)
        fill(80, 80, 80);
        stroke(50, 50, 50);
        strokeWeight(3);
        circle(0, 0, 50);

        // Turret detail ring
        noFill();
        stroke(100, 100, 100);
        strokeWeight(4);
        circle(0, 0, 45);

        // Center pivot bolt
        fill(40, 40, 40);
        noStroke();
        circle(0, 0, 15);

        pop();
    }
}

class Projectile {
    constructor(x, y, angle, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        let weapon = weapons[type];

        let power = weapon.power;
        this.vx = cos(angle) * power;
        this.vy = sin(angle) * power;
        this.gravity = weapon.gravity;
        this.size = weapon.size;
        this.color = weapon.color;
        this.trail = [];
        this.rotation = 0;
    }

    update() {
        this.vy += this.gravity * gameSpeed;
        this.x += this.vx * gameSpeed;
        this.y += this.vy * gameSpeed;
        this.rotation += 0.1 * gameSpeed;

        // Homing missile (weapon index 3)
        if (this.type === 3 && targets.length > 0) {
            let nearestTarget = null;
            let nearestDist = Infinity;
            for (let target of targets) {
                let d = dist(this.x, this.y, target.x, target.y);
                if (d < nearestDist) {
                    nearestDist = d;
                    nearestTarget = target;
                }
            }

            if (nearestTarget) {
                let targetAngle = atan2(nearestTarget.y - this.y, nearestTarget.x - this.x);
                let currentAngle = atan2(this.vy, this.vx);

                let angleDiff = targetAngle - currentAngle;
                if (angleDiff > PI) angleDiff -= TWO_PI;
                if (angleDiff < -PI) angleDiff += TWO_PI;

                let newAngle = currentAngle + constrain(angleDiff, -0.05, 0.05);
                let speed = sqrt(this.vx * this.vx + this.vy * this.vy);
                this.vx = cos(newAngle) * speed;
                this.vy = sin(newAngle) * speed;
            }
        }

        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 8) { // Reduced trail for mobile
            this.trail.shift();
        }
    }

    display() {
        if (this.type === 0) {
            noFill();
            for (let i = 0; i < this.trail.length - 1; i++) {
                let alpha = map(i, 0, this.trail.length, 0, 200);
                stroke(50, 50, 50, alpha);
                strokeWeight(map(i, 0, this.trail.length, 2, 8));
                line(this.trail[i].x, this.trail[i].y, this.trail[i + 1].x, this.trail[i + 1].y);
            }

            fill(this.color[0], this.color[1], this.color[2]);
            stroke(20, 20, 20);
            strokeWeight(2);
            circle(this.x, this.y, this.size);

            fill(80, 80, 80);
            noStroke();
            circle(this.x - 3, this.y - 3, 8);
        }
        else if (this.type === 1) {
            // Lightning bolt
            for (let i = 0; i < 5; i++) {
                let angle = random(TWO_PI);
                let length = random(15, 25);
                stroke(100, 200, 255, 150);
                strokeWeight(2);
                line(
                    this.x + cos(angle) * 8,
                    this.y + sin(angle) * 8,
                    this.x + cos(angle) * length,
                    this.y + sin(angle) * length
                );
            }

            for (let r = this.size * 2; r > 0; r -= 5) {
                fill(100, 200, 255, 50);
                noStroke();
                circle(this.x, this.y, r);
            }

            fill(200, 230, 255);
            noStroke();
            circle(this.x, this.y, this.size);

            fill(255, 255, 255);
            circle(this.x, this.y, this.size * 0.6);
        }
        else if (this.type === 2) {
            // Scatter shot
            for (let i = 0; i < this.trail.length; i++) {
                let alpha = map(i, 0, this.trail.length, 0, 180);
                fill(255, 140, 0, alpha);
                noStroke();
                circle(this.trail[i].x, this.trail[i].y, this.size * 0.7 * (i / this.trail.length));
            }

            push();
            translate(this.x, this.y);
            rotate(this.rotation);

            fill(255, 160, 0, 100);
            noStroke();
            circle(0, 0, this.size * 1.2);

            fill(this.color[0], this.color[1], this.color[2]);
            stroke(200, 100, 0);
            strokeWeight(2);
            circle(0, 0, this.size);

            fill(255, 200, 100);
            noStroke();
            circle(-4, -4, 8);

            pop();
        }
        else if (this.type === 3) {
            // Homing missile
            for (let i = 0; i < this.trail.length - 1; i++) {
                let alpha = map(i, 0, this.trail.length, 0, 150);
                stroke(200, 200, 200, alpha);
                strokeWeight(map(i, 0, this.trail.length, 1, 5));
                line(this.trail[i].x, this.trail[i].y, this.trail[i + 1].x, this.trail[i + 1].y);
            }

            push();
            translate(this.x, this.y);
            let angle = atan2(this.vy, this.vx);
            rotate(angle);

            fill(this.color[0], this.color[1], this.color[2]);
            stroke(160, 30, 30);
            strokeWeight(2);
            rect(-this.size * 0.6, -this.size * 0.4, this.size * 1.2, this.size * 0.8, 3);

            fill(200, 60, 60);
            triangle(this.size * 0.6, 0, this.size * 0.9, -this.size * 0.3, this.size * 0.9, this.size * 0.3);

            fill(180, 40, 40);
            triangle(-this.size * 0.4, 0, -this.size * 0.7, -this.size * 0.5, -this.size * 0.7, 0);
            triangle(-this.size * 0.4, 0, -this.size * 0.7, this.size * 0.5, -this.size * 0.7, 0);

            fill(255, 200, 0);
            noStroke();
            circle(-this.size * 0.6, 0, 8);
            fill(255, 100, 0);
            circle(-this.size * 0.65, 0, 6);

            pop();
        }
    }

    hits(target) {
        let d = dist(this.x, this.y, target.x, target.y);
        return d < this.size / 2 + target.size / 2;
    }

    isOffScreen() {
        return this.x < -100 || this.x > width + 100 || this.y < -100 || this.y > height + 100;
    }
}

class Target {
    constructor(side, y, type) {
        this.type = type;
        this.y = y;
        this.size = type.size;
        this.points = type.points;
        this.speed = type.speed * targetSpeed;
        this.maxHp = type.hp || 1;
        this.hp = this.maxHp;

        if (side === 'left') {
            this.x = -80;
            this.vx = this.speed;
            this.direction = 1;
        } else {
            this.x = width + 80;
            this.vx = -this.speed;
            this.direction = -1;
        }

        this.vy = random(-0.5, 0.5);
        this.angle = 0;
        this.wingFlap = 0;
    }

    update() {
        this.x += this.vx * gameSpeed;
        this.y += this.vy * gameSpeed;
        this.angle += 0.02 * gameSpeed;
        this.wingFlap += 0.15 * gameSpeed;

        if (this.y < height * 0.1 || this.y > height * 0.65) {
            this.vy *= -1;
        }
    }

    display() {
        push();
        translate(this.x, this.y);

        if (this.type.name === 'bird') {
            this.drawBird();
        } else if (this.type.name === 'balloon') {
            this.drawBalloon();
        } else if (this.type.name === 'plane') {
            this.drawPlane();
        } else if (this.type.name === 'rocket') {
            this.drawRocket();
        } else if (this.type.name === 'ufo') {
            this.drawUFO();
        } else if (this.type.name === 'bomber') {
            this.drawBomber();
        } else if (this.type.name === 'shielded') {
            this.drawShielded();
        } else if (this.type.name === 'decoy') {
            this.drawDecoy();
        } else if (this.type.name === 'decoy_mini') {
            this.drawDecoyMini();
        }

        fill(255, 255, 255);
        stroke(0, 0, 0);
        strokeWeight(2);
        textAlign(CENTER);
        textSize(18);
        textStyle(BOLD);
        text(`+${this.points}`, 0, this.size / 2 + 25);

        pop();
    }

    drawBird() {
        scale(this.direction, 1);
        fill(101, 67, 33);
        noStroke();
        ellipse(0, 0, 30, 20);
        circle(12, -5, 18);
        fill(255);
        circle(16, -5, 6);
        fill(0);
        circle(17, -5, 3);
        fill(255, 165, 0);
        triangle(20, -5, 28, -3, 20, -1);
        let wingY = sin(this.wingFlap) * 10;
        fill(80, 50, 20);
        ellipse(-8, wingY, 25, 12);
        ellipse(-8, -wingY, 25, 12);
        triangle(-15, 0, -25, -8, -25, 8);
    }

    drawBalloon() {
        stroke(100, 100, 100);
        strokeWeight(2);
        noFill();
        bezier(0, 15, -5, 25, 5, 35, 0, 50);
        fill(255, 100, 100);
        stroke(200, 50, 50);
        strokeWeight(2);
        ellipse(0, 0, this.size * 0.8, this.size);
        fill(255, 150, 150);
        noStroke();
        ellipse(-8, -10, 15, 20);
        fill(200, 50, 50);
        ellipse(0, this.size / 2, 8, 10);
    }

    drawPlane() {
        scale(this.direction, 1);
        fill(200, 200, 200);
        stroke(150, 150, 150);
        strokeWeight(2);
        ellipse(0, 0, 50, 15);
        fill(180, 180, 180);
        rect(-15, -2, 30, 4);
        rect(-25, -25, 8, 50);
        triangle(-20, 0, -30, -15, -30, 0);
        triangle(-20, 0, -30, 15, -30, 0);
        fill(100, 150, 200);
        ellipse(15, 0, 12, 10);
        push();
        translate(25, 0);
        rotate(frameCount * 0.5);
        stroke(100);
        strokeWeight(3);
        line(-15, 0, 15, 0);
        line(0, -15, 0, 15);
        pop();
        fill(100, 150, 200);
        circle(5, 0, 6);
        circle(-5, 0, 6);
    }

    drawRocket() {
        rotate(PI / 2);
        fill(220, 220, 220);
        stroke(180, 180, 180);
        strokeWeight(2);
        rect(-10, -20, 20, 40, 5);
        fill(255, 0, 0);
        triangle(-10, -20, 10, -20, 0, -35);
        fill(255, 100, 100);
        triangle(-10, 15, -20, 20, -10, 20);
        triangle(10, 15, 20, 20, 10, 20);
        fill(100, 150, 200);
        circle(0, -5, 10);
        fill(255, 0, 0);
        rect(-10, 0, 20, 6);
        push();
        translate(0, 20);
        fill(255, 200, 0);
        noStroke();
        triangle(-8, 0, 0, 15 + random(5), 8, 0);
        fill(255, 100, 0);
        triangle(-5, 0, 0, 10 + random(5), 5, 0);
        pop();
    }

    drawUFO() {
        fill(100, 200, 255, 200);
        stroke(80, 150, 200);
        strokeWeight(2);
        arc(0, 0, this.size * 0.6, this.size * 0.5, PI, TWO_PI);
        fill(150, 255, 150);
        noStroke();
        circle(0, -5, 15);
        fill(0);
        circle(-3, -7, 4);
        circle(3, -7, 4);
        fill(180, 180, 180);
        stroke(140, 140, 140);
        strokeWeight(2);
        ellipse(0, 0, this.size, this.size * 0.4);
        let lightColors = [color(255, 0, 0), color(0, 255, 0), color(0, 0, 255), color(255, 255, 0)];
        for (let i = 0; i < 4; i++) {
            let angle = (frameCount * 0.1) + (i * PI / 2);
            let lx = cos(angle) * (this.size * 0.35);
            let ly = sin(angle) * (this.size * 0.15);
            fill(lightColors[i]);
            noStroke();
            circle(lx, ly, 8);
        }
        fill(100, 255, 255, 100);
        noStroke();
        ellipse(0, 5, this.size * 0.8, 20);
    }

    drawBomber() {
        scale(this.direction, 1);
        fill(120, 120, 120);
        stroke(80, 80, 80);
        strokeWeight(2);
        ellipse(0, 0, 60, 20);
        fill(100, 100, 100);
        rect(-20, -3, 40, 6);
        rect(-30, -30, 10, 60);
        triangle(-25, 0, -35, -18, -35, 0);
        triangle(-25, 0, -35, 18, -35, 0);
        fill(80, 120, 150);
        ellipse(20, 0, 15, 12);
        fill(60, 60, 60);
        rect(10, -8, 12, 6, 3);
        rect(10, 2, 12, 6, 3);
        push();
        translate(22, -5);
        rotate(frameCount * 0.4);
        stroke(80);
        strokeWeight(2);
        line(-8, 0, 8, 0);
        pop();
        push();
        translate(22, 5);
        rotate(frameCount * 0.4);
        stroke(80);
        strokeWeight(2);
        line(-8, 0, 8, 0);
        pop();
        fill(139, 0, 0);
        noStroke();
        rect(-5, 5, 10, 4);
    }

    drawShielded() {
        scale(this.direction, 1);
        fill(100, 100, 110);
        stroke(70, 70, 80);
        strokeWeight(2);
        rect(-this.size * 0.4, -this.size * 0.25, this.size * 0.8, this.size * 0.5, 5);
        fill(90, 90, 100);
        circle(0, 0, this.size * 0.5);
        fill(70, 70, 80);
        rect(this.size * 0.2, -5, this.size * 0.3, 10, 3);
        if (this.hp > 1) {
            for (let r = this.size * 0.8; r > 0; r -= 10) {
                fill(100, 150, 255, 30);
                noStroke();
                circle(0, 0, r);
            }
            fill(100, 150, 255, 100);
            stroke(150, 200, 255);
            strokeWeight(3);
            circle(0, 0, this.size * 0.7);
        } else {
            stroke(100, 150, 255, 100);
            strokeWeight(2);
            noFill();
            arc(-this.size * 0.2, -this.size * 0.2, this.size * 0.4, this.size * 0.4, 0, PI);
            arc(this.size * 0.1, this.size * 0.1, this.size * 0.3, this.size * 0.3, PI, TWO_PI);
        }
        fill(255);
        noStroke();
        textAlign(CENTER);
        textSize(16);
        textStyle(BOLD);
        text(this.hp, 0, -this.size * 0.5);
    }

    drawDecoy() {
        scale(this.direction, 1);
        let shimmer = sin(frameCount * 0.2) * 30 + 150;
        fill(100, 255, 255, shimmer);
        stroke(50, 200, 200, shimmer + 50);
        strokeWeight(2);
        beginShape();
        vertex(-this.size * 0.3, 0);
        vertex(0, -this.size * 0.35);
        vertex(this.size * 0.3, 0);
        vertex(0, this.size * 0.35);
        endShape(CLOSE);
        fill(150, 255, 255, shimmer);
        noStroke();
        for (let i = 0; i < 4; i++) {
            let angle = (frameCount * 0.1) + (i * PI / 2);
            let px = cos(angle) * this.size * 0.4;
            let py = sin(angle) * this.size * 0.4;
            circle(px, py, 8);
        }
        if (random() < 0.1) {
            stroke(100, 255, 255, 200);
            strokeWeight(1);
            line(-this.size * 0.3, random(-this.size * 0.3, this.size * 0.3),
                 this.size * 0.3, random(-this.size * 0.3, this.size * 0.3));
        }
        fill(200, 255, 255, shimmer + 50);
        noStroke();
        circle(0, 0, 10);
    }

    drawDecoyMini() {
        scale(this.direction, 1);
        let shimmer = sin(frameCount * 0.3) * 40 + 120;
        fill(100, 255, 255, shimmer);
        stroke(50, 200, 200, shimmer + 50);
        strokeWeight(1);
        beginShape();
        vertex(-this.size * 0.35, 0);
        vertex(0, -this.size * 0.4);
        vertex(this.size * 0.35, 0);
        vertex(0, this.size * 0.4);
        endShape(CLOSE);
        fill(200, 255, 255, shimmer + 50);
        noStroke();
        circle(0, 0, 6);
    }

    isOffScreen() {
        return this.x < -100 || this.x > width + 100;
    }
}

class PowerUp {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.size = 40;
        this.angle = 0;
        this.bobble = 0;
    }

    update() {
        this.angle += 0.05 * gameSpeed;
        this.bobble += 0.08 * gameSpeed;
        this.y += sin(this.bobble) * 1.5 * gameSpeed;
    }

    display() {
        push();
        translate(this.x, this.y);
        rotate(this.angle);

        for (let r = this.size * 1.5; r > 0; r -= 8) {
            fill(255, 215, 0, 30);
            noStroke();
            circle(0, 0, r);
        }

        if (this.type === 'star') {
            fill(255, 215, 0);
            noStroke();
            star(0, 0, this.size * 0.4, this.size * 0.6, 5);
        } else if (this.type === 'ammo') {
            fill(100, 200, 100);
            stroke(60, 140, 60);
            strokeWeight(2);
            rect(-this.size * 0.3, -this.size * 0.3, this.size * 0.6, this.size * 0.6, 5);
            fill(255);
            noStroke();
            textAlign(CENTER, CENTER);
            textSize(20);
            text('+15', 0, 0);
        } else if (this.type === 'shield') {
            fill(100, 150, 255);
            noStroke();
            beginShape();
            vertex(0, -this.size * 0.5);
            vertex(this.size * 0.4, -this.size * 0.2);
            vertex(this.size * 0.4, this.size * 0.3);
            vertex(0, this.size * 0.5);
            vertex(-this.size * 0.4, this.size * 0.3);
            vertex(-this.size * 0.4, -this.size * 0.2);
            endShape(CLOSE);
        } else if (this.type === 'timeSlow') {
            for (let r = this.size * 1.5; r > 0; r -= 8) {
                fill(138, 43, 226, 40);
                noStroke();
                circle(0, 0, r);
            }

            fill(138, 43, 226);
            stroke(88, 23, 176);
            strokeWeight(3);
            circle(0, 0, this.size * 0.7);

            stroke(255, 255, 255);
            strokeWeight(3);
            line(0, 0, 0, -this.size * 0.25);
            strokeWeight(2);
            line(0, 0, this.size * 0.15, 0);

            fill(255);
            noStroke();
            circle(0, 0, 5);
        }

        pop();
    }

    isOffScreen() {
        return this.y > height + 100;
    }
}

class Bomb {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vy = 2;
        this.vx = random(-1, 1);
        this.size = 25;
    }

    update() {
        this.y += this.vy * gameSpeed;
        this.x += this.vx * gameSpeed;
        this.vy += 0.15 * gameSpeed;
    }

    display() {
        push();
        fill(40, 40, 40);
        stroke(20, 20, 20);
        strokeWeight(2);
        circle(this.x, this.y, this.size);
        pop();
    }

    hitsGround() {
        return this.y > height * 0.75;
    }

    isOffScreen() {
        return this.y > height + 100;
    }
}

class Explosion {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.size = 0;
        this.maxSize = type === 'fire' ? 120 : 80;
        this.life = 30;
        this.type = type;
    }

    update() {
        this.size = min(this.size + 8, this.maxSize);
        this.life--;
    }

    display() {
        push();
        let alpha = map(this.life, 0, 30, 0, 200);
        if (this.type === 'fire') {
            fill(255, 100, 0, alpha);
        } else {
            fill(200, 200, 200, alpha);
        }
        noStroke();
        circle(this.x, this.y, this.size);
        pop();
    }

    isDone() {
        return this.life <= 0;
    }
}

class Boss {
    constructor(type, wave) {
        this.type = type;
        this.wave = wave;
        this.maxHp = 20 + (wave * 5);
        this.hp = this.maxHp;
        this.size = 120;
        this.points = 1000 + (wave * 200);
        this.x = width / 2;
        this.y = height * 0.25;
        this.vx = 2;
        this.vy = 1;
        this.defeated = false;

        if (type === 'colossus') {
            this.name = 'IRON COLOSSUS';
        } else if (type === 'dragons') {
            this.name = 'TWIN DRAGONS';
        } else {
            this.name = 'MEGA BOMBER';
        }

        document.getElementById('bossName').textContent = this.name;
        this.updateHPBar();
    }

    update() {
        this.x += this.vx * gameSpeed;
        this.y += this.vy * gameSpeed;

        if (this.x < this.size || this.x > width - this.size) {
            this.vx *= -1;
        }
        if (this.y < height * 0.1 || this.y > height * 0.4) {
            this.vy *= -1;
        }
    }

    display() {
        push();
        fill(150, 50, 50);
        stroke(255);
        strokeWeight(3);
        circle(this.x, this.y, this.size);
        pop();
    }

    takeDamage(damage) {
        this.hp -= damage;
        if (this.hp <= 0) {
            this.hp = 0;
            this.defeated = true;
        }
        this.updateHPBar();
    }

    updateHPBar() {
        let percent = (this.hp / this.maxHp) * 100;
        document.getElementById('bossHpFill').style.width = percent + '%';
    }
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    if (cannon) {
        cannon.x = width / 2;
        cannon.y = height - 50;
    }

    // Recreate cached gradients when window size changes
    createGradientCache();
}
</script>
</body>
</html>
